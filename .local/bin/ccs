#!/usr/bin/env bash

# See https://github.com/xwmx/bash-boilerplate/blob/master/bash-subcommands

set -o nounset
set -o errexit
trap 'echo "Aborting due to errexit on line $LINENO. Exit code: $?" >&2' ERR
set -o errtrace
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Globals
###############################################################################

CCS_VERSION="${CCS_VERSION:-1240}"
CCS_HOME="${HOME}/ti/ccs${CCS_VERSION}/ccs"
CCS_WORKSPACE=${CCS_WORKSPACE:-out}

CCS_USAGE="
Usage: ccs <subcommand> [options]

Subcommands:
    build       Build project
    clean       Clean project
    discover    Discover tools and products in $HOME/ti
    flash       Flash project to a target
    erase       Mass erase a CC13xx or CC26xx target.
    import      Import a project (.projectspec)

Options:
    -h    Show this help message and exit

Environment variables:
    CCS_VERSION      CCS version to use (default: 1240)
    CCS_WORKSPACE    CCS workspace to use (default: ./out)
"

###############################################################################
# Error Messages
###############################################################################

# _exit_1()
#
# Usage:
#   _exit_1 <command>
#
# Description:
#   Exit with status 1 after executing the specified command with output
#   redirected to standard error. The command is expected to print a message
#   and should typically be either `echo`, `printf`, or `cat`.
_exit_1() {
    {
        printf "%s " "$(tput setaf 1)!$(tput sgr0)"
        "${@}"
    } 1>&2
    exit 1
}

###############################################################################
# Utility Functions
###############################################################################

_ccs() {
    local ccs_cli="${CCS_HOME}/eclipse/ccs-server-cli.sh"
    local args=("-noSplash")
    local application="${1}"

    if [[ $CCS_VERSION -lt 2000 ]]; then
        ccs_cli="${CCS_HOME}/eclipse/eclipse"

        if [[ "${application}" == "initialize" ]]; then
            application="com.ti.common.core.initialize"
        else
            application="com.ti.ccstudio.apps.${application}"
        fi
        args+=("-data" "${CCS_WORKSPACE}" "-application" "${application}")
    else
        args+=("-workspace" "${CCS_WORKSPACE}" "-application" "com.ti.ccs.apps.${application}")
    fi

    args+=("${@:2}")

    ${ccs_cli} "${args[@]}"
}

_dslite() {
    local dslite_cli="${CCS_HOME}/ccs_base/DebugServer/bin/DSLite"
    local args=("${@:-}")
    ${dslite_cli} "${args[@]}"
}

_help() {
    echo "${@:-${CCS_USAGE}}"
    exit 0
}

# _blank()
#
# Usage:
#   _blank <argument>
#
# Exit / Error Status:
#   0 (success, true)  If <argument> is not present or null.
#   1 (error,  false)  If <argument> is present and not null.
_blank() {
    [[ -z "${1:-}" ]]
}

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Exit / Error Status:
#   0 (success, true) If a command with <name> is defined in the current
#                     environment.
#   1 (error,  false) If not.
#
# Information on why `hash` is used
_command_exists() {
    hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains <query> <list-item>...
#
# Exit / Error Status:
#   0 (success, true)  If the item is included in the list.
#   1 (error,  false)  If not.
#
# Examples:
#   _contains "${_query}" "${_list[@]}"
_contains() {
    local _query="${1:-}"
    shift

    if [[ -z "${_query}" ]] ||
        [[ -z "${*:-}" ]]; then
        return 1
    fi

    for __element in "${@}"; do
        [[ "${__element}" == "${_query}" ]] && return 0
    done

    return 1
}

# SUBCOMMANDS ################################################################

discover() {
    _ccs initialize -ccs.toolDiscoveryPath "${HOME}/ti" -rtsc.productDiscoveryPath "${HOME}/ti"
}

import() {
    local usage="
Usage: ccs import [options]

Options:
    -p <projectspec>  Path to the projectspec to import
    -h                Show this help message and exit
"
    local projectspec=""
    local extra_args=()

    OPTIND=1
    while getopts "hp:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        p) projectspec="${OPTARG}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${projectspec}"; then
        mapfile -t specs < <(find . -type f -name "*.projectspec" -printf "%P\n")

        if _blank "${specs[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find a projectspec on path '$PWD'\\n"
        elif [ "${#specs[@]}" -eq 1 ]; then
            projectspec="${specs[0]}"
        else
            PS3="Select a projectspec to import: "
            select spec in "${specs[@]}"; do
                if [[ -n $spec ]]; then
                    projectspec="${spec}"
                    break
                fi
            done
        fi
    fi

    _ccs projectImport -ccs.location "${projectspec}" "${extra_args[@]}"
}

build() {
    local usage="
Usage: ccs build [options]

NOTE: Setting -c <config> changes the active build configuration

Options:
    -p <project>  Project to build
    -c <config>   Set project build configuration
    -h            Show this help message and exit
"
    local project=""
    local extra_args=("-ccs.listErrors" "-ccs.listProblems")

    OPTIND=1
    while getopts "hc:p:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        c) extra_args+=("-ccs.configuration" "${OPTARG}") ;;
        p) project="${OPTARG}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${project}"; then
        mapfile -t projects < <(
            find "${CCS_WORKSPACE}" -maxdepth 1 -type d -not -wholename "${CCS_WORKSPACE}" -not -name ".metadata" -printf "%P\n"
        )

        if _blank "${projects[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any projects to build in '${CCS_WORKSPACE}'\\n"
        elif [ "${#projects[@]}" -eq 1 ]; then
            project="${projects[0]}"
        else
            PS3="Select a project to build: "
            select prj in "${projects[@]}"; do
                if [[ -n $prj ]]; then
                    project="${prj}"
                    break
                fi
            done
        fi
    fi

    _ccs projectBuild -ccs.projects "${project}" "${extra_args[@]}"
}

clean() {
    local usage="
Usage: ccs clean [options]

Options:
    -p <project>  Project to clean
    -c <config>   Build configuration to clean
    -h            Show this help message and exit
"
    local project="${1:-}"
    local extra_args=()

    OPTIND=1
    while getopts "hc:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        c) extra_args+=("-ccs.configuration" "${OPTARG}") ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${project}"; then
        mapfile -t projects < <(
            find "${CCS_WORKSPACE}" -maxdepth 1 -type d -not -wholename "${CCS_WORKSPACE}" -not -name ".metadata" -printf "%P\n"
        )

        if _blank "${projects[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any projects to clean in '${CCS_WORKSPACE}'\\n"
        elif [ "${#projects[@]}" -eq 1 ]; then
            project="${projects[0]}"
        else
            PS3="Select a project to clean: "
            select prj in "${projects[@]}"; do
                if [[ -n $prj ]]; then
                    project="${prj}"
                    break
                fi
            done
        fi
    fi

    _ccs projectBuild -ccs.projects "${project}" -ccs.clean "${extra_args[@]}"
}

erase() {
    local usage="
Usage: ccs flash [options]

Performs a mass-erase on the connected target.

Options:
    -c <config>   Target configuration to use (.ccxml)
    -h            Show this help message and exit
"
    local config=""

    OPTIND=1
    while getopts "hc:" opt; do
        case $opt in
        c) config="${OPTARG}" ;;
        h) _help "${usage}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${config}"; then
        mapfile -t configurations < <(find "${CCS_WORKSPACE}" -type f -name "*.ccxml")

        if _blank "${configurations[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any target configurations '${CCS_WORKSPACE}'\\n"
        elif [ "${#configurations[@]}" -eq 1 ]; then
            config="${configurations[0]}"
        else
            PS3="Select a target configuration: "
            select cfg in "${configurations[@]}"; do
                if [[ -n $cfg ]]; then
                    config="${cfg}"
                    break
                fi
            done
        fi
    fi

    _dslite cc13xx-cc26xx-mass-erase -c "${config}"
}

flash() {
    local usage="
Usage: ccs flash [options]

Flash the connected target with the given image. A menu of discovered images (.bin or .hex) is provided unless
explicitly set through -i <image>. By default, binary images will be flashed to 0x00000000 address, but can be
overriden with the -a <address> option.

Options:
    -a <address>  Address to load the image to (only relevant for .bin images, defaults to 0x00000000)
    -i <image>    Image to flash to the target
    -c <config>   Target configuration to use (.ccxml)
    -r            Performs a board reset after program has been loaded and verified
    -v            Verify the image
    -h            Show this help message and exit
"
    local address="0x00000000"
    local image=""
    local config=""
    local extra_args=()

    OPTIND=1
    while getopts "hvra:c:i:" opt; do
        case $opt in
        a) address="${OPTARG}" ;;
        i) image+="${OPTARG}" ;;
        c) config="${OPTARG}" ;;
        r) extra_args+=("-r" "2") ;;
        v) extra_args+=("-v") ;;
        h) _help "${usage}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${image}"; then
        mapfile -t executables < <(find "${CCS_WORKSPACE}" -type f -name "*.hex" -o -name "*.bin")

        if _blank "${executables[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any executables to flash in '${CCS_WORKSPACE}'\\n"
        elif [ "${#executables[@]}" -eq 1 ]; then
            image="${executables[0]}"
        else
            PS3="Select an executables to flash: "
            select exe in "${executables[@]}"; do
                if [[ -n $exe ]]; then
                    image="${exe}"
                    break
                fi
            done
        fi
    fi

    if _blank "${config}"; then
        mapfile -t configurations < <(find "${CCS_WORKSPACE}" -type f -name "*.ccxml")

        if _blank "${configurations[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any target configurations '${CCS_WORKSPACE}'\\n"
        elif [ "${#configurations[@]}" -eq 1 ]; then
            config="${configurations[0]}"
        else
            PS3="Select a target configuration: "
            select cfg in "${configurations[@]}"; do
                if [[ -n $cfg ]]; then
                    config="${cfg}"
                    break
                fi
            done
        fi
    fi

    if [[ "${image}" == *.bin ]]; then
        image="${image},${address}"
    fi

    _dslite flash -f -c "${config}" "${extra_args[@]}" "${image}"
}

# Program Option Parsing ######################################################

unset options
# while the number of arguments is greater than 0
while ((${#})); do
    case "${1}" in
    # if option is of type -ab
    -[!-]?*)
        # loop over each character starting with the second
        for ((i = 1; i < ${#1}; i++)); do
            # extract 1 character from position 'i'
            c="${1:i:1}"
            # add current char to options
            options+=("-${c}")
        done
        ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
        options+=("${1%%=*}" "${1#*=}")
        ;;
    # end of options, stop breaking them up
    --)
        options+=(--endopts)
        shift
        options+=("${@}")
        break
        ;;
    # otherwise, nothing special
    *)
        options+=("${1}")
        ;;
    esac

    shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

_SUBCOMMAND=""
_SUBCOMMAND_ARGUMENTS=()

while ((${#})); do
    __opt="${1}"

    shift

    case "${__opt}" in
    -h)
        # Check if we should pass help option to subcommand
        if [ -z "${_SUBCOMMAND}" ]; then
            _help "${CCS_USAGE}"
        else
            _SUBCOMMAND_ARGUMENTS+=("${__opt}")
        fi
        ;;
    *)
        # The first non-option argument is assumed to be the subcommand name.
        # All subsequent arguments are added to $_SUBCOMMAND_ARGUMENTS.
        if [[ -n "${_SUBCOMMAND}" ]]; then
            _SUBCOMMAND_ARGUMENTS+=("${__opt}")
        else
            _SUBCOMMAND="${__opt}"
        fi
        ;;
    esac
done

###############################################################################
# Main
###############################################################################

# Declare the $_DEFINED_SUBCOMMANDS array.
_DEFINED_SUBCOMMANDS=()

# _main()
#
# Usage:
#   _main
#
# Description:
#   The primary function for starting the program.
_main() {
    if [[ -z "${_SUBCOMMAND}" ]]; then
        _help "${CCS_USAGE}"
    fi

    for __name in $(declare -F); do
        # Each element has the format `declare -f function_name`, so set the name
        # to only the 'function_name' part of the string.
        local _function_name
        _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

        if ! {
            [[ -z "${_function_name:-}" ]] ||
                [[ "${_function_name}" =~ ^_(.*) ]]
        }; then
            _DEFINED_SUBCOMMANDS+=("${_function_name}")
        fi
    done

    # If the subcommand is defined, run it, otherwise return an error.
    if _contains "${_SUBCOMMAND}" "${_DEFINED_SUBCOMMANDS[@]:-}"; then
        # Pass all comment arguments to the program except for the first ($0).
        ${_SUBCOMMAND} "${_SUBCOMMAND_ARGUMENTS[@]:-}"
    else
        _exit_1 printf "Unknown subcommand: %s\\n" "${_SUBCOMMAND}"
    fi
}

_main
