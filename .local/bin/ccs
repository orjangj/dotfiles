#!/usr/bin/env bash

# See https://github.com/xwmx/bash-boilerplate/blob/master/bash-subcommands

set -o nounset
set -o errexit
trap 'echo "Aborting due to errexit on line $LINENO. Exit code: $?" >&2' ERR
set -o errtrace
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Globals
###############################################################################

CCS_VERSION="${CCS_VERSION:-1240}"
CCS_HOME="${HOME}/ti/ccs${CCS_VERSION}/ccs"
CCS_WORKSPACE=${CCS_WORKSPACE:-out}

CCS_USAGE="
Usage: ccs <subcommand> [options]

Subcommands:
    build       Build project
    clean       Clean project
    discover    Discover tools and products in $HOME/ti
    flash       Flash project to a target
    import      Import a project (.projectspec)

Options:
    -h    Show this help message and exit

Environment variables:
    CCS_VERSION      CCS version to use (default: 1240)
    CCS_WORKSPACE    CCS workspace to use (default: ./out)
"

###############################################################################
# Error Messages
###############################################################################

# _exit_1()
#
# Usage:
#   _exit_1 <command>
#
# Description:
#   Exit with status 1 after executing the specified command with output
#   redirected to standard error. The command is expected to print a message
#   and should typically be either `echo`, `printf`, or `cat`.
_exit_1() {
    {
        printf "%s " "$(tput setaf 1)!$(tput sgr0)"
        "${@}"
    } 1>&2
    exit 1
}

###############################################################################
# Utility Functions
###############################################################################

_ccs() {
    local ccs_cli="${CCS_HOME}/eclipse/ccs-server-cli.sh"
    local args=("-noSplash")
    local application="${1}"

    if [[ $CCS_VERSION -lt 2000 ]]; then
        ccs_cli="${CCS_HOME}/eclipse/eclipse"

        if [[ "${application}" == "initialize" ]]; then
            application="com.ti.common.core.initialize"
        else
            application="com.ti.ccstudio.apps.${application}"
        fi
        args+=("-data" "${CCS_WORKSPACE}" "-application" "${application}")
    else
        args+=("-workspace" "${CCS_WORKSPACE}" "-application" "com.ti.ccs.apps.${application}")
    fi

    args+=("${@:2}")

    ${ccs_cli} "${args[@]}"
}

_dslite() {
    local dslite_cli="${CCS_HOME}/ccs_base/DebugServer/bin/DSLite"
    ${dslite_cli} flash -f "${@:-}"
}

_help() {
    echo "${@:-${CCS_USAGE}}"
    exit 0
}

# _blank()
#
# Usage:
#   _blank <argument>
#
# Exit / Error Status:
#   0 (success, true)  If <argument> is not present or null.
#   1 (error,  false)  If <argument> is present and not null.
_blank() {
    [[ -z "${1:-}" ]]
}

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Exit / Error Status:
#   0 (success, true) If a command with <name> is defined in the current
#                     environment.
#   1 (error,  false) If not.
#
# Information on why `hash` is used
_command_exists() {
    hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains <query> <list-item>...
#
# Exit / Error Status:
#   0 (success, true)  If the item is included in the list.
#   1 (error,  false)  If not.
#
# Examples:
#   _contains "${_query}" "${_list[@]}"
_contains() {
    local _query="${1:-}"
    shift

    if [[ -z "${_query}" ]] ||
        [[ -z "${*:-}" ]]; then
        return 1
    fi

    for __element in "${@}"; do
        [[ "${__element}" == "${_query}" ]] && return 0
    done

    return 1
}

# SUBCOMMANDS ################################################################

discover() {
    _ccs initialize -ccs.toolDiscoveryPath "${HOME}/ti" -rtsc.productDiscoveryPath "${HOME}/ti"
}

import() {
    local usage="
Usage: ccs import [options]

Options:
    -p <projectspec>  Path to the projectspec to import
    -h                Show this help message and exit
"
    local projectspec=""
    local extra_args=()

    OPTIND=1
    while getopts "hp:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        p) projectspec="${OPTARG}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${projectspec}"; then
        mapfile -t files < <(find . -type f -name "*.projectspec")
        PS3="Select a projectspec to import: "
        select file in "${files[@]}"; do
            if [[ -n $file ]]; then
                projectspec=$(realpath "${file}")
                break
            fi
        done

        if _blank "${projectspec}"; then
            echo "${usage}"
            _exit_1 printf "Could not find a projectspec on path '$PWD'\\n"
        fi
    fi

    _ccs projectImport -ccs.location "${projectspec}" "${extra_args[@]}"
}

build() {
    local usage="
Usage: ccs build [options]
    
Options:
    -p <project>        Project to build
    -c <configuration>  Project build configuration to build
    -h                  Show this help message and exit
"
    local project=""
    local extra_args=("-ccs.listErrors" "-ccs.listProblems")

    OPTIND=1
    while getopts "hc:p:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        c) extra_args+=("-ccs.configuration ${OPTARG}") ;;
        p) project="${OPTARG}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${project}"; then
        mapfile -t projects < <(
            cd "${CCS_WORKSPACE}"
            find . -maxdepth 1 -type d -not -name "." -not -name ".metadata" -printf "%f\n"
        )

        if _blank "${projects[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any projects to build in '${CCS_WORKSPACE}'\\n"
        elif [ "${#projects[@]}" -eq 1 ]; then
            project="${projects[0]}"
        else
            PS3="Select a project to build: "
            select prj in "${projects[@]}"; do
                if [[ -n $prj ]]; then
                    project="${prj}"
                    break
                fi
            done
        fi
    fi

    _ccs projectBuild -ccs.projects "${project}" "${extra_args[@]}"
}

clean() {
    local usage="
Usage: ccs clean [options]
    
Options:
    -p <project>        Project to clean
    -c <configuration>  Build configuration to clean
    -h                  Show this help message and exit
"
    local project="${1:-}"
    local extra_args=()

    OPTIND=1
    while getopts "hc:" opt; do
        case $opt in
        h) _help "${usage}" ;;
        c) extra_args+=("-ccs.configuration ${OPTARG}") ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${project}"; then
        mapfile -t projects < <(
            cd "${CCS_WORKSPACE}"
            find . -maxdepth 1 -type d -not -name "." -not -name ".metadata" -printf "%f\n"
        )

        if _blank "${projects[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any projects to clean in '${CCS_WORKSPACE}'\\n"
        elif [ "${#projects[@]}" -eq 1 ]; then
            project="${projects[0]}"
        else
            PS3="Select a project to clean: "
            select prj in "${projects[@]}"; do
                if [[ -n $prj ]]; then
                    project="${prj}"
                    break
                fi
            done
        fi
    fi

    _ccs projectBuild -ccs.projects "${project}" -ccs.clean "${extra_args[@]}"
}

flash() {
    local usage="
Usage: ccs flash [options]
    
Options:
    -i <image>   Image (.hex) to flash to the target
    -c <config>  Target configuration to use (.ccxml)
    -r <reset>   Set reset operation to be done after flashing the target
    -h           Show this help message and exit
"
    local image=""
    local config=""
    local extra_args=()

    OPTIND=1
    while getopts "hc:i:r:" opt; do
        case $opt in
        i) image+="${OPTARG}" ;;
        c) config="${OPTARG}" ;;
        r) extra_args+=("-r ${OPTARG}") ;;
        h) _help "${usage}" ;;
        *) exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    if _blank "${image}"; then
        mapfile -t executables < <(
            cd "${CCS_WORKSPACE}"
            find . -type f -name "*.hex"
        )

        if _blank "${executables[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any executables to flash in '${CCS_WORKSPACE}'\\n"
        elif [ "${#executables[@]}" -eq 1 ]; then
            image="${executables[0]}"
        else
            PS3="Select an executables to flash: "
            select exe in "${executables[@]}"; do
                if [[ -n $exe ]]; then
                    image="${exe}"
                    break
                fi
            done
        fi
    fi

    if _blank "${config}"; then
        local project=""
        project=$(basename -s ".hex" "${image}")
        local search_path="${CCS_WORKSPACE}/${project}/targetConfigs"

        mapfile -t configurations < <(
            cd "${search_path}"
            find . -type f -name "*.ccxml" -printf "%f\n"
        )

        if _blank "${configurations[*]}"; then
            echo "${usage}"
            _exit_1 printf "Could not find any target configurations '${CCS_WORKSPACE}'\\n"
        elif [ "${#configurations[@]}" -eq 1 ]; then
            config="${configurations[0]}"
        else
            PS3="Select a target configuration: "
            select cfg in "${configurations[@]}"; do
                if [[ -n $cfg ]]; then
                    config="${cfg}"
                    break
                fi
            done
        fi

        config="${search_path}/${config}"
    fi

    _dslite -c "${config}" "${extra_args[@]}" "${image}"
}

# Program Option Parsing ######################################################

unset options
# while the number of arguments is greater than 0
while ((${#})); do
    case "${1}" in
    # if option is of type -ab
    -[!-]?*)
        # loop over each character starting with the second
        for ((i = 1; i < ${#1}; i++)); do
            # extract 1 character from position 'i'
            c="${1:i:1}"
            # add current char to options
            options+=("-${c}")
        done
        ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
        options+=("${1%%=*}" "${1#*=}")
        ;;
    # end of options, stop breaking them up
    --)
        options+=(--endopts)
        shift
        options+=("${@}")
        break
        ;;
    # otherwise, nothing special
    *)
        options+=("${1}")
        ;;
    esac

    shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

_SUBCOMMAND=""
_SUBCOMMAND_ARGUMENTS=()

while ((${#})); do
    __opt="${1}"

    shift

    case "${__opt}" in
    -h)
        # Check if we should pass help option to subcommand
        if [ -z "${_SUBCOMMAND}" ]; then
            _help "${CCS_USAGE}"
        else
            _SUBCOMMAND_ARGUMENTS+=("${__opt}")
        fi
        ;;
    *)
        # The first non-option argument is assumed to be the subcommand name.
        # All subsequent arguments are added to $_SUBCOMMAND_ARGUMENTS.
        if [[ -n "${_SUBCOMMAND}" ]]; then
            _SUBCOMMAND_ARGUMENTS+=("${__opt}")
        else
            _SUBCOMMAND="${__opt}"
        fi
        ;;
    esac
done

###############################################################################
# Main
###############################################################################

# Declare the $_DEFINED_SUBCOMMANDS array.
_DEFINED_SUBCOMMANDS=()

# _main()
#
# Usage:
#   _main
#
# Description:
#   The primary function for starting the program.
_main() {
    if [[ -z "${_SUBCOMMAND}" ]]; then
        _help "${CCS_USAGE}"
    fi

    for __name in $(declare -F); do
        # Each element has the format `declare -f function_name`, so set the name
        # to only the 'function_name' part of the string.
        local _function_name
        _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

        if ! {
            [[ -z "${_function_name:-}" ]] ||
                [[ "${_function_name}" =~ ^_(.*) ]]
        }; then
            _DEFINED_SUBCOMMANDS+=("${_function_name}")
        fi
    done

    # If the subcommand is defined, run it, otherwise return an error.
    if _contains "${_SUBCOMMAND}" "${_DEFINED_SUBCOMMANDS[@]:-}"; then
        # Pass all comment arguments to the program except for the first ($0).
        ${_SUBCOMMAND} "${_SUBCOMMAND_ARGUMENTS[@]:-}"
    else
        _exit_1 printf "Unknown subcommand: %s\\n" "${_SUBCOMMAND}"
    fi
}

_main
